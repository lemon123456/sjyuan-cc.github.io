---
layout: post
permalink: /dojo/ci/pipeline
title: "Jenkins构建可持续部署的Pipeline（策略）"
date: 2016-12-27
category: "DOJO-CI"
tags: ["Dojo", "CI"]

author: "袁慎建"
published: true
type: "original"

---

* content
{:toc}


## 持续之根本

>CI的核心目标是快速频繁集成代码，通过一些手段（编译、代码检查、运行测试、覆盖率等）来持续地提供及时有效的反馈，可持续从何而来？前提就是这些手段都是行之有效的。

将CI的那些手段对应到每一次集成中的各个步骤，这些步骤应该是值得信赖的，比如单元测试、集成测试、E2E测试，确保它们都能够真实有效地反馈当前代码库的集成状态。试想一下，集成中单元测试步骤虽然做了，但其实没有运行任何测试，亦或代码中没有添加任何测试，那么即便这一步通过了，发布的软件也是不可靠的。所以持续之根本取决于每一步可靠性。

以一个Java Web工程为例，一次集成通常含有以下步骤：

![]({{ '/assets/img/dojo/ci/ci-steps.png' }})

这里面的每一个步骤循序渐进，必须都是通过后才能持续往后走，而通过也必须是有意义的通过，而不只是亮了一个空壳绿灯。

>具体步骤因项目而异，比如有些项目的E2E测试运行时间很长，E2E测试可能就选在夜间运行，而不是在打包前必须要运行的步骤。另外，有些项目只有单元测试。

---

## CI何所为
>所谓CI，本质上在一个可被触及的中心服务器去集成那些提交到中心代码库的代码，并将一些原本可以重复手工完成检验步骤自动化起来。

无CI论者`NoCI`会说：“CI其实没啥用，你们大可把代码提交，我pull下来做集成。我在我的机器跑测试，然后进行部署，一旦挂了我通知你们...” 

一句话包含了多少辛酸和无奈：

```
1. 每天那么多次提交，NoCI这哥们完全不能知晓其他人何时提交。
2. 运行了测试挂了，通知谁？都不知道是谁的提交导致挂了，提供不了即时的反馈。
3. 即便别人提交后通知他，那他每天要多次重复去做这项工作，恐怕没有什么产出了，就等着被fire了。
4. 自己机器还要开发，还要运行很多其他程序，运行测试跑了1个小时，一天跑八次测试就该下班了。
```

听起来，`NoCI`这哥们也能做这些事情，只不过效果没那么好，还附带了被Fire的风险。实际上，CI也并不神奇，一句话`简单`概括CI何所为:

```
CI做的事情就是将重复的手工工作自动化管理起来，并提供即时有效的反馈。
```

>友情提示：
>
>反过来想，CI能做的事情，你都能在本地手动去做，所以在搭建CI的时候，可以现在本地手动验证你在CI所设置的任务是否正确。

---

## 常规策略
从毕业到现在，经历了多个不同项目，从`!测试 && !CI`-->`本地测试`-->`CI && 测试`-->`强制 CI && 测试`，对CI历经了从0到1的过程，一开始非常享受CI所带来的好处，如今便是`身处酒巷，久而不觉酒香`的状态：在一个项目启动的时候，首先会在Iteration 0将CI作为必备的基础设施搭建好，然后步入开发阶段。

CI策略由简入繁，简单的比如一个Android的build，跑完单元测试、打包apk、发布apk就完事了，复杂的就好比一个微服务的CI，每一个微服务除了完善的`单元测试`以及`严格的集成测试`，还需要定义清楚各个微服务之间如下一些构建依赖关系：

```
1. 构建的顺序，服务B会依赖服务A的构建参数或者只有A成功后才构建B。
2. 微服务部署的顺序，定义哪些服务部署是允许失败的，以及失败后的救援措施。
3. 微服务在多个环境的部署时的版本控制。
```

实际中的CI实践通常介于简单和复杂之间，这里我以过去几个项目经历为常规CI的依据，主要包含了四个步骤：

```
1. 获取源码，解析依赖。
2. 运行测试。
3. 打包。
4. 部署/发布
```

最重要的属2和4。因为测试是代码库质量的保证，而测试也是我们搭建CI的前提，没有测试的CI犹如牛刀杀鸡。而部署则是关系到软件的交付，只有做到自动化部署发布，CI才算完成了它的最后使命（那些由某些客观因素导致无法自动化部署的场景不在讨论范围之内）。

---

### 测试
运行测试的策略通常借鉴于[测试金字塔]()，单元测试、集成测试、E2E测试。关于测试的最佳实践则是将这三部分测试都涵盖进去。首先CI会每次自动运行单元测试，然后自动运行集成测试，最后是E2E测试。完美的情况下，每一次提交三部分测试都会运行，只有所有测试通过后才进入下一个环节。而在实际中，有些项目E2E测试运行的时间较长，以至于对集成和部署造成了一定的影响，此时我们需要做一些优化措施，可以并发运行E2E测试：

![]({{ '/assets/img/dojo/ci/e2e-test-slaves.png' }})

>实践指导：  
>测试三步曲中，最难的是数据准备，要做到测试能够并发运行，就需要在设计E2E测试用例的时候，保证Test Case的准备数据和数据回滚的独立性，但考虑到每一个Test Case都完全独立，成本较大（数据库数据的初始化和回滚），通常是对同一个功能模块中存在依赖关系的Test Case做一次数据准备和数据回滚，Test Case则按照一定的顺序运行。或者根据并发Salve的粒度来划分独立边界。

关于测试数据准备和数据回滚的边界，举个例子：

```
一个电子商务系统中有登录、用户管理、地址管理、商品管理模块、购物车5个模块，我们将登录、用户管理和地址管理模块的测试放在的Slave A上，将商品管理和购物车模块的测试放在Slave B上运行，边界划分的粒度就存在以下三种：
1. 以单个Test Case作为边界，运行任何Test Case都会做一次初始化和回滚。（非常耗时）
2. 以功能模块作为边界，每运行一个模块的测试做一次初始化和回滚。（较耗时）
3. 以Slave作为边界，比如Salve A在运行E2E测试的只做一次初始化和回滚，且Slave A和Slave B的数据互不干扰。（推荐的方式）
```
















