---
layout: post
permalink: /dojo/ci/container-strategy
title: "持续集成的容器化策略"
date: 2017-02-01
category: "DOJO-CI"
tags: ["Dojo", "CI"]

author: "袁慎建"
published: true
type: "original"

---

* content
{:toc}

---


## 何为容器

>近两年，随着`容器`（以[Docker]()为首）的兴起，解决了诸多传统交付过程中的问题，像`一次构建，随处运行`以及`开发即生产`这些话传为佳言。

在传统的交付过程中，开发人员和测试人员在开发测试的时候，所有的功能都正确无误，但部署到生产环境后，莫名其妙的问题就来了，这是因为开发、测试和生产环境都存在差异性，系统环境引发的问题。除此之外，生产环境通常会存在多个，每部署一个新的环境意味着需要解决系统环境的差异性引发的问题，造成了无畏的浪费。

Docker容器的诞生，使得开发测试时的环境可以直接部署到生产环境上，有效地屏蔽了环境的差异性，解决了这个问题。它将软件运行所需的任何环境都封装在一个容器内部，任何需要部署的地方，只需要正常运行该容器一个完整的软件，而容器可以很方便地运行在Linux内核上。

### 容器化部署

如此便捷，为何不在CI上使用容器华方案呢？我们之前的一个Python项目就使用了这种方案，CI服务的启动、测试运行、打包、部署，都是基于Docker容器完成的。我们的CI Pipeline如下图：

![]({{ '/assets/img/dojo/ci/docker-pipeline.png' }})

Pipeline中有五个步骤：

```
1. Portal，CI的入口，pull代码，编译，构建镜像（容器的载体）。
2. 单元测试，使用 $ docker run ...在容器中运行单元测试。
3. 集成测试，使用 $ docker run ...在容器中运行集成测试。
4. E2E测试，使用 $ docker run ...在容器中运行E2E测试。
6. 部署，测试通过后，将Portal中编译好的镜像部署到目标环境中。
```

细心的读者可能已经发现了一个问题，这没有打包过程，因为Python语言术语解释型语言，通常直接源码部署。但另外一个问题来了，如果部署的步骤直接部署了Portal中的镜像，是不是会将测试代码都打包了？

漂亮，这绝对是个好问题，以下列出了一些解决方案：

```
1. 构建镜像的时候不将测试代码添加进去，而在测试步骤，运行容器时将测试目录挂载到容器中。
2. 部署的时候重新使用Portal的代码库构建一个不包含测试代码的镜像进行部署。
3. 将代码库中部署到目标环境，在目标环境中构建镜像并运行容器。
```
每种方案，各有千秋，我个人推荐的是第二种，理由此处不详叙。

---

### 容器的管理
一个Web项目，通常会有应用、数据库、缓存等服务，而容器化方案推崇一个容器运行一个服务，通过容器互联的方式，将它们联结在一起构成一个可用的系统。所以，在部署的时候，我们通常会部署多个镜像，简单的比如单应用：主应用*1 + 数据库\*1，复杂的比如微服务模式： 负载均衡\*1 + 主应用模块\*n + 数据库\*n + 缓存\*n + ...，如何去管理这些容器的生命周期，这就是目前微服务系统架构师所面临的挑战，再者，包括如何定义和拆分服务、如何实现服务发现、如何保证安全性、如何实现服务高可靠性（99%）、如何实现热部署等。

[Docker]()官方提供了容器管理的命令行工具[Docker compose]()，我们用它可以管理多个容器的互联，另外[Docker rancher]提供了一个高效的可视化的管理方案。[Docker Hub]()也提供了容器部署和管理一体化方案，它可以跟AWS进行集成。















